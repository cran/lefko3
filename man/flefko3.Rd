% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrixcreation.R
\name{flefko3}
\alias{flefko3}
\title{Create Function-based Historical Matrix Projection Model}
\usage{
flefko3(
  year = "all",
  patch = "all",
  stageframe,
  supplement = NA,
  repmatrix = NA,
  overwrite = NA,
  data = NA,
  modelsuite = NA,
  surv_model = NA,
  obs_model = NA,
  size_model = NA,
  repst_model = NA,
  fec_model = NA,
  jsurv_model = NA,
  jobs_model = NA,
  jsize_model = NA,
  jrepst_model = NA,
  paramnames = NA,
  inda = 0,
  indb = 0,
  indc = 0,
  surv_dev = 0,
  obs_dev = 0,
  size_dev = 0,
  repst_dev = 0,
  fec_dev = 0,
  jsurv_dev = 0,
  jobs_dev = 0,
  jsize_dev = 0,
  jrepst_dev = 0,
  repmod = 1,
  yearcol = NA,
  patchcol = NA,
  year.as.random = FALSE,
  patch.as.random = FALSE,
  randomseed = NA,
  negfec = FALSE,
  reduce = FALSE,
  err_check = FALSE
)
}
\arguments{
\item{year}{A variable corresponding to year or observation time, or a set
of such values, given in values associated with the year term used in linear 
model development. Can also equal \code{all}, in which case matrices will
be estimated for all years. Defaults to \code{all}.}

\item{patch}{A variable designating which patches or subpopulations will have
matrices estimated. Should be set to specific patch names, or to \code{all}
if matrices should be estimated for all patches. Defaults to \code{all}.}

\item{stageframe}{A stageframe object that includes information on the size,
observation status, propagule status, immaturity status, and maturity status
of each ahistorical stage. Should also incorporate bin widths if size is
continuous.}

\item{supplement}{An optional data frame of class \code{lefkoSD} that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for fecundity. This data
frame should be produced using the \code{\link{supplemental}()} function. Can
be used in place of or in addition to an overwrite table (see 
\code{overwrite} below) and a reproduction matrix (see \code{repmatrix}
below).}

\item{repmatrix}{A reproduction matrix, which is an optional matrix composed
mostly of 0s, with non-zero values for each potentially new individual (row)
born to each reproductive stage (column). Entries act as multipliers on
fecundity, with 1 equaling full fecundity. Fecundity multipliers provided
this way supplement rather than replace those provided in \code{supplement}.
If left blank, then \code{flefko3()} will assume that all stages marked as
reproductive produce offspring at 1x that of fecundity estimated in provided
linear models, and that fecundity will be into the first stage noted as
propagule or immature. To prevent this behavior, input just \code{0}, which
will result in fecundity being estimated only for transitions noted in
\code{supplement} above. May be the dimensions of either a historical or an
ahistorical matrix. If the latter, then all stages will be used in time
\emph{t}-1 for each suggested ahistorical transition.}

\item{overwrite}{An optional data frame developed with the
\code{\link{overwrite}()} function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in \code{supplement}.}

\item{data}{The historical vertical demographic data frame used to estimate
vital rates (class \code{hfvdata}), which is required to initialize years and
patches properly.}

\item{modelsuite}{An optional \code{lefkoMod} object holding the vital rate
models. If given, then \code{surv_model}, \code{obs_model},
\code{size_model}, \code{repst_model}, \code{fec_model}, \code{jsurv_model},
\code{jobs_model}, \code{jsize_model}, \code{jrepst_model},
\code{paramnames}, \code{yearcol}, and \code{patchcol} are not required. One
or more of these models should include size or reproductive status in time
\emph{t}-1.}

\item{surv_model}{A linear model predicting survival probability. This can 
be a model of class \code{glm} or \code{glmer}, and requires a predicted
binomial variable under a logit link. If given, then will overwrite any
survival probability model given in \code{modelsuite}. This model must have
been developed in a modeling exercise testing the impacts of times \emph{t}
and \emph{t}-1.}

\item{obs_model}{A linear model predicting sprouting or observation
probability. This can be a model of class \code{glm} or \code{glmer}, and
requires a predicted binomial variable under a logit link. If given, then 
will overwrite any observation probability model given in \code{modelsuite}.
This model must have been developed in a modeling exercise testing the
impacts of times \emph{t} and \emph{t}-1.}

\item{size_model}{A linear model predicting size. This can be a model of
class \code{glm} or \code{glmer}, both of which require a predicted poisson
variable under a log link, or a model of class \code{lm} or \code{lmer}, in
which a Gaussian response is assumed. If given, then will overwrite any size
model given in \code{modelsuite}.This model must have been developed in a
modeling exercise testing the impacts of times \emph{t} and \emph{t}-1.}

\item{repst_model}{A linear model predicting reproduction probability. This 
can be a model of class \code{glm} or \code{glmer}, and requires a predicted
binomial variable under a logit link. If given, then will overwrite any
reproduction probability model given in \code{modelsuite}. This model must
have been developed in a modeling exercise testing the impacts of times
\emph{t} and \emph{t}-1.}

\item{fec_model}{A linear model predicting fecundity. This can be a model of
class \code{glm} or \code{glmer}, and requires a predicted poisson variable
under a log link. If given, then will overwrite any fecundity model given in 
\code{modelsuite}. This model must have been developed in a modeling exercise 
testing the impacts of times \emph{t} and \emph{t}-1.}

\item{jsurv_model}{A linear model predicting juvenile survival probability.
This can be a model of class \code{glm} or \code{glmer}, and requires a
predicted binomial variable under a logit link. If given, then will overwrite
any juvenile survival probability model given in \code{modelsuite}. This
model must have been developed in a modeling exercise testing the impacts of
times \emph{t} and \emph{t}-1.}

\item{jobs_model}{A linear model predicting juvenile sprouting or observation
probability. This can be a model of class \code{glm} or \code{glmer}, and
requires a predicted binomial variable under a logit link. If given, then
will overwrite any juvenile observation probability model given in 
\code{modelsuite}. This model must have been developed in a modeling exercise
testing the impacts of times \emph{t} and \emph{t}-1.}

\item{jsize_model}{A linear model predicting juvenile size. This can be a
model of class \code{glm} or \code{glmer}, both of which require a predicted
poisson variable under a log link, or a model of class \code{lm} or 
\code{lmer}, in which a Gaussian response is assumed. If given, then will
overwrite any juvenile size model given in \code{modelsuite}. This model must
have been developed in a modeling exercise testing the impacts of times
\emph{t} and \emph{t}-1.}

\item{jrepst_model}{A linear model predicting reproduction probability of a 
mature individual that was immature in the previous year. This can be a model
of class \code{glm} or \code{glmer}, and requires a predicted binomial
variable under a logit link. If given, then will overwrite any reproduction
probability model given in \code{modelsuite}. This model must have been
developed in a modeling exercise testing the impacts of times \emph{t} and
\emph{t}-1.}

\item{paramnames}{A dataframe with two columns, the first showing the general
model terms that will be used in matrix creation, and the second showing the
equivalent terms used in modeling. Only required if \code{modelsuite} is not 
supplied.}

\item{inda}{A numeric value to use for individual covariate a. Defaults to 0.}

\item{indb}{A numeric value to use for individual covariate b. Defaults to 0.}

\item{indc}{A numeric value to use for individual covariate c. Defaults to 0.}

\item{surv_dev}{A numeric value to be added to the y-intercept in the linear
model for survival probability.}

\item{obs_dev}{A numeric value to be added to the y-intercept in the linear
model for observation probability.}

\item{size_dev}{A numeric value to be added to the y-intercept in the linear
model for size.}

\item{repst_dev}{A numeric value to be added to the y-intercept in the linear
model for probability of reproduction.}

\item{fec_dev}{A numeric value to be added to the y-intercept in the linear
model for fecundity.}

\item{jsurv_dev}{A numeric value to be added to the y-intercept in the linear
model for juvenile survival probability.}

\item{jobs_dev}{A numeric value to be added to the y-intercept in the linear
model for juvenile observation probability.}

\item{jsize_dev}{A numeric value to be added to the y-intercept in the linear
model for juvenile size.}

\item{jrepst_dev}{A numeric value to be added to the y-intercept in the
linear model for juvenile reproduction probability.}

\item{repmod}{A scalar multiplier of fecundity. Defaults to 1.}

\item{yearcol}{The variable name or column number corresponding to year 
in time \emph{t} in the dataset. Not needed if \code{modelsuite} is supplied.}

\item{patchcol}{The variable name or column number corresponding to patch in 
the dataset. Not needed if \code{modelsuite} is supplied.}

\item{year.as.random}{A logical term indicating whether coefficients for
missing patches within vital rate models should be estimated as random
intercepts. Defaults to FALSE, in which case missing time step coefficients 
are set to 0.}

\item{patch.as.random}{A logical term indicating whether coefficients for
missing patches within vital rate models should be estimated as random
intercepts. Defaults to FALSE, in which case missing patch coefficients 
are set to 0.}

\item{randomseed}{A numeric value used as a seed to generate random estimates
for missing time step and patch coefficients, if either \code{year.as.random}
or \code{patch.as.random} is set to TRUE. Defaults to 
\code{\link{set.seed}()} default.}

\item{negfec}{A logical value denoting whether fecundity values estimated to
be negative should be reset to 0. Defaults to FALSE.}

\item{reduce}{A logical value denoting whether to remove historical stages
associated solely with 0 transitions. These are only removed in cases where
the associated row and column sums in ALL matrices estimated equal 0. 
Defaults to FALSE.}

\item{err_check}{A logical value indicating whether to add matrices of vital
rate probabilities associated with each matrix. Defaults to FALSE.}
}
\value{
If all inputs are properly formatted, then this function will return
an object of class \code{lefkoMat}, which is a list with the following
elements:

\item{A}{A list of full projection matrices in order of sorted patches and
years. All matrices output in the \code{matrix} class.}
\item{U}{A list of survival transition matrices sorted as in \code{A}. All 
matrices output in the \code{matrix} class.}
\item{F}{A list of fecundity matrices sorted as in \code{A}. All matrices 
output in the \code{matrix} class.}
\item{hstages}{A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs.}
\item{ahstages}{A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.}
\item{labels}{A data frame showing the patch and year of each matrix in 
order. In \code{flefko3()}, only one population may be analyzed at once, and
so \code{pop = NA}.}
\item{matrixqc}{A short vector describing the number of non-zero elements in
\code{U} and \code{F} matrices, and the number of annual matrices.}
\item{modelqc}{This is the \code{qc} portion of the \code{modelsuite} input.}
\item{prob_out}{An optional element only added if \code{err_check = TRUE}.
This is a list of vital rate probability matrices, with 4 columns in the
order of survival, observation probability, reproduction probability, and
size transition probability.}
}
\description{
Function \code{flefko3()} returns function-based historical MPMs
corresponding to the patches and years given, including the associated
component transition and fecundity matrices, data frames detailing the
characteristics of the ahistorical stages used and historical stage pairs
created, and a data frame characterizing the patch and year combinations
corresponding to these matrices. Unlike \code{\link{rlefko3}()}, this
function currently does not distinguish populations within the same dataset.
}
\section{Notes}{

The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
\code{supplement} or \code{repmatrix}. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
\code{supplement} is provided and a \code{repmatrix} is not, or if
\code{repmatrix} is set to 0, then only fecundity transitions noted in the
supplement will be set to non-zero values. To use the default behavior of
setting all reproductive stages to reproduce at full fecundity into immature
and propagule stages but incorporate given or proxy survival transitions,
input those given and proxy transitions through the \code{overwrite} option.

The reproduction matrix (field \code{repmatrix}) may be supplied as either
historical or ahistorical. If provided as ahistorical, then \code{flefko3()}
will assume that all historical transitions involving stages noted for times
\emph{t} and \emph{t}+1 should be set to the respective fecundity multipliers
noted.

Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations. Should the aim of analysis be a general
MPM that does not distinguish these patches or subpopulations, the
\code{patchcol} variable should be left to NA, which is the default.

Input options including multiple variable names must be entered in the order
of variables in time \emph{t}+1, \emph{t}, and \emph{t}-1. Rearranging the
order WILL lead to erroneous calculations, and will probably also lead to
fatal errors.

Using the \code{err_check} option will produce a matrix of 4 columns, each
characterizing a different vital rate. The product of each row yields an
element in the associated \code{$U} matrix. The number and order of elements
in each column of this matrix matches the associated matrix in column vector
format. Use of this option is generally for the purposes of debugging code.
}

\examples{
\donttest{
# Lathyrus example
data(lathyrus)

sizevector <- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector <- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector <- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector <- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector <- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector <- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset <- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec <- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln <- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln <- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 <- round(lathvertln$feca2)
lathvertln$feca1 <- round(lathvertln$feca1)
lathvertln$feca3 <- round(lathvertln$feca3)

lathmodelsln3 <- modelsearch(lathvertln, historical = TRUE, 
  approach = "mixed", suite = "main", 
  vitalrates = c("surv", "obs", "size", "repst", "fec"), juvestimate = "Sdl",
  bestfit = "AICc&k", sizedist = "gaussian", fecdist = "poisson", 
  indiv = "individ", patch = "patchid", year = "year2",year.as.random = TRUE,
  patch.as.random = TRUE, show.model.tables = TRUE, quiet = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
lathsupp3 <- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "rep", "rep"),
  stage1 = c("Sd", "rep", "rep", "all", "all"), 
  givenrate = c(0.345, 0.345, 0.054, NA, NA),
  multiplier = c(NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 3, 3), stageframe = lathframeln, historical = TRUE)

lathmat3ln <- flefko3(year = "all", patch = "all", stageframe = lathframeln, 
  modelsuite = lathmodelsln3, data = lathvertln, supplement = lathsupp3, 
  patchcol = "patchid", yearcol = "year2", year.as.random = FALSE,
  patch.as.random = FALSE, reduce = FALSE)

summary(lathmat3ln)

# Alternatively, we can use overwrite() and a reproductive matrix to provide
# supplemental info

lathrepmln <- matrix(0, 21, 21)
lathrepmln[1, c(13:21)] <- 0.345
lathrepmln[2, c(13:21)] <- 0.054

lathover3 <- overwrite(stage3 = c("Sd", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd"), stage1 = c("Sd", "rep", "rep"), 
  givenrate = c(0.345, 0.345, 0.054))

lathmat3ln_alt <- flefko3(year = "all", patch = "all",
  stageframe = lathframeln, modelsuite = lathmodelsln3, data = lathvertln,
  repmatrix = lathrepmln, overwrite = lathover3, patchcol = "patchid",
  yearcol = "year2", year.as.random = FALSE, patch.as.random = FALSE,
  reduce = FALSE)

summary(lathmat3ln_alt)

# Cypripedium example
rm(list = ls(all=TRUE))

data(cypdata)

sizevector <- c(0, 0, 0, 0, 0, seq(from = 0, t = 24), seq(from = 1, to = 24))
stagevector <- c("SD", "P1", "P2", "P3", "SL", "D", "V1", "V2", "V3", "V4", "V5", 
  "V6", "V7", "V8", "V9", "V10", "V11", "V12", "V13", "V14", "V15", "V16", "V17", 
  "V18", "V19", "V20", "V21", "V22", "V23", "V24", "F1", "F2", "F3", "F4", "F5",
  "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17",
  "F18", "F19", "F20", "F21", "F22", "F23", "F24")
repvector <- c(0, 0, 0, 0, 0, rep(0, 25), rep(1, 24))
obsvector <- c(0, 0, 0, 0, 0, 0, rep(1, 48))
matvector <- c(0, 0, 0, 0, 0, rep(1, 49))
immvector <- c(0, 1, 1, 1, 1, rep(0, 49))
propvector <- c(1, rep(0, 53))
indataset <- c(0, 0, 0, 0, 0, rep(1, 49))

cypframe <- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset)

vertdata <- verticalize3(data = cypdata, noyears = 6, firstyear = 2004, 
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04", 
  stageassign = cypframe, stagesize = "sizeadded", NAas0 = TRUE)

cypmodels3 <- modelsearch(vertdata, historical = TRUE, approach = "mixed", 
  vitalrates = c("surv", "obs", "size", "repst", "fec"), sizedist = "negbin", 
  size.trunc = TRUE, fecdist = "poisson", fec.zero = TRUE, suite = "main", 
  size = c("size3added", "size2added", "size1added"), quiet = TRUE)

cypsupp3 <- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "SL", "SL", "D", "V1", "V2", "V3", "D", "V1", "V2", "V3", "SD", "P1"), 
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL", 
    "SL", "SL", "SL", "SL", "SL", "SL", "rep", "rep"), 
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "SL", "P3", "P3",
    "P3", "P3", "SL", "SL", "SL", "SL", "mat", "mat"), 
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "D", "V1", "V2", "V3", "D",
    "V1", "V2", "V3", NA, NA), 
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "D", "D", "D", "D", "D", 
    "D", "D", "D", NA, NA), 
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "D", "D", "D", "D", "D", 
    "D", "D", "D", NA, NA), 
  givenrate = c(0.08, 0.08, 0.1, 0.1, 0.1, 0.1, 0.125, 0.2, 0.2, NA, NA, NA, NA, 
    NA, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c("S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S",
    "S", "S", "S", "R", "R"), stageframe = cypframe)

cypmatrix3 <- flefko3(stageframe = cypframe, supplement = cypsupp3, 
  modelsuite = cypmodels3, data = vertdata, yearcol = "year2",
  year.as.random = TRUE)

summary(cypmatrix3)

# Here is a version using a reproductive matrix and overwrite table instead

rep.assumptions <- matrix(0, 54, 54)
rep.assumptions[1:2,31:54] <- 0.5

cypover3 <- overwrite(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL", "SL", 
    "SL", "D", "V1", "V2", "V3", "D", "V1", "V2", "V3"), 
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL", 
    "SL", "SL", "SL", "SL", "SL", "SL"), 
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "SL", "P3", "P3",
    "P3", "P3", "SL", "SL", "SL", "SL"), 
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "D", "V1", "V2", "V3", "D",
    "V1", "V2", "V3"), 
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "D", "D", "D", "D", "D", 
    "D", "D", "D"), 
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "D", "D", "D", "D", "D", 
    "D", "D", "D"), 
  givenrate = c(0.08, 0.08, 0.1, 0.1, 0.1, 0.1, 0.125, 0.2, 0.2, NA, NA, NA, NA, 
    NA, NA, NA, NA), 
  type = c("S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S",
    "S", "S", "S"))

cypmatrix3_alt <- flefko3(stageframe = cypframe, repmatrix = rep.assumptions,
  overwrite = cypover3, modelsuite = cypmodels3, data = vertdata,
  yearcol = "year2", year.as.random = TRUE)

summary(cypmatrix3_alt)
}

}
